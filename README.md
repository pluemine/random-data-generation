# Random Data Generation

## Introduction

Welcome to the Random Data Generation project! Our tool is designed to generate diverse and unique datasets suitable for training optical character recognition (OCR) models, such as TrOCR. Here's why you might find our tool useful:

1. **Rich and Diverse Data**: The dataset generated by our tool includes a variety of data types and formats, such as symbols, Thai numerals, Thai date formats, and more. This diversity ensures that your OCR model is trained on a comprehensive range of data, making it more robust and adaptable to different contexts.

2. **Optimized for Large Datasets**: Our tool is optimized for generating large volumes of unique values efficiently. Whether you need hundreds of thousands or even millions of data points, our solution handles large-scale data generation with impressive performance.

3. **Customizable and Flexible**: You can specify various types of data to be generated, including currency values, phone numbers, license plates, and more. This flexibility allows you to tailor the dataset to your specific needs, whether for synthetic data creation or other purposes.

4. **Performance-Driven**: With detailed performance metrics, you can make informed decisions on the best optimization levels to suit your requirements, ensuring that you balance speed and memory usage effectively.

## Getting Started

To begin with this project, you need to install the necessary dependencies. Follow these steps:

### Install Dependencies

Ensure you have `pip3` installed. Then, execute the following command to install the project dependencies:

```bash
pip3 install -e .
```

The `-e` flag installs the package in "editable" mode, allowing you to make changes to the code and have them immediately reflected without needing to reinstall.

## Overview

This project includes a script for generating random data based on various types. The script can generate data such as phone numbers, currency values, dates, license plates, and more. The generated data can be saved to a specified output directory.

### Prerequisites

Ensure you have Python 3.x installed on your machine. Check your Python version by running:

```bash
python3 --version
```

## Project Structure

The project directory is organized as follows:

```
project_root/
│
├── scripts/
│   └── random_generator.py
│
├── test/
│   └── test.py
│
├── src/
│   └── code
│
└── README.md
```

## Running the Script

To run the `random_generator.py` script, use the following command:

```bash
python3 scripts/random_generator.py --type <type> --number <number> --output <output_path>
```

### Command-Line Arguments

- `--type <type>`: Specifies the type of data to generate. Supported types include:

  - `currency`: Generate random currency values.
  - `numeric`: Generate random numeric values.
  - `date`: Generate random dates.
  - `license_plate`: Generate random license plates.
  - `phone_number`: Generate random phone numbers.

- `--number <number>`: Specifies the number of items to generate. The default value is 250,000. If omitted, 250,000 items will be generated by default.

- `--output <output_path>`: Specifies the directory where the output files will be saved. Replace `<output_path>` with the actual path where you want the files to be saved.

### Example Command

```bash
python3 scripts/random_generator.py --type phone_number --number 100 --output /Users/xxxxx/Desktop/output
```

This command generates 100 phone numbers and saves them to the `/Users/xxxxx/Desktop/output` directory.

### Example of Generated Dataset

Here are some examples of the generated phone numbers:

```
๐๘๔-๗๓๐-๒๖๐๐
+6682109-0685
0604879430
06-2293-5998
+66992886949
```

### Checkpoints and Caching

The specified `--output` path may be used to create checkpoints or cache files to improve performance or resume operations. Ensure that the directory specified in `--output` has sufficient space and is writable, as checkpoint files may be created in this location.

## Performance

This section provides a comprehensive performance analysis of different optimization levels, focusing on execution time and memory usage across various numbers of iterations.

### Execution Time and Memory Usage

#### **Iteration: 10,000**

| Optimization Level    | Mean Execution Time | Peak Memory Usage |
| --------------------- | ------------------- | ----------------- |
| **Non-Optimized**     | 0.08 seconds        | 1.52 MB           |
| **Optimized Level 1** | 0.04 seconds        | 1.43 MB           |
| **Optimized Level 2** | 0.02 seconds        | 1.42 MB           |

#### **Iteration: 100,000**

| Optimization Level    | Mean Execution Time | Peak Memory Usage |
| --------------------- | ------------------- | ----------------- |
| **Non-Optimized**     | 0.74 seconds        | 14.06 MB          |
| **Optimized Level 1** | 0.43 seconds        | 13.34 MB          |
| **Optimized Level 2** | 0.16 seconds        | 13.34 MB          |

---

### Optimization Level Comparison (1,000,000 Iterations)

| Optimization Level    | Mean Execution Time | Peak Memory Usage | Speedup      |
| --------------------- | ------------------- | ----------------- | ------------ |
| **Non-Optimized**     | 7.43 seconds        | 132.16 MB         | Baseline     |
| **Optimized Level 1** | 4.37 seconds        | 123.29 MB         | 1.70x faster |
| **Optimized Level 2** | 1.62 seconds        | 123.25 MB         | 4.58x faster |

---

### Detailed Improvements

#### **Non-Optimized**

- **Mean Execution Time (1,000,000 Iterations):** 7.43 seconds
- **Peak Memory Usage (1,000,000 Iterations):** 132.16 MB
- **Baseline Performance:** Represents the default configuration without optimizations.

#### **Optimized Level 1**

- **Mean Execution Time (1,000,000 Iterations):** 4.37 seconds
- **Peak Memory Usage (1,000,000 Iterations):** 123.29 MB
- **Speedup:** 1.70x faster than Non-Optimized
- **Improvements:**
  - Enhanced random boolean generation.
  - More efficient data generation algorithms and string operations.
  - Reduced memory footprint compared to the non-optimized version.

#### **Optimized Level 2**

- **Mean Execution Time (1,000,000 Iterations):** 1.62 seconds
- **Peak Memory Usage (1,000,000 Iterations):** 123.25 MB
- **Speedup:** 4.58x faster than Non-Optimized
- **Improvements:**
  - Utilizes precomputed necessary data for random selections, which significantly speeds up the data generation process.
  - Further optimization of boolean generation.
  - Advanced techniques and algorithms for data generation reduce execution time dramatically while keeping memory usage minimal.

### Machine Specifications and Testing Context

- **Machine:** Apple M3 Pro with an 11-core CPU
- **Power Mode:** Normal mode
- **Number of Iterations:** 1,000,000
- **Data Type Tested:** Currency
- **Test Focus:** Focus exclusively on the execution of functions, without involving I/O operations such as printing or file writing.

**Note:** Performance results are specific to the `currency` data type and may vary for other data types or in real-world scenarios due to potential I/O-bound operations not included in these benchmarks.

### Performance by Data Type

| Data Type          | Iterations | Optimization Level | Mean Execution Time |
| ------------------ | ---------- | ------------------ | ------------------- |
| **Currencies**     | 1,000,000  | Level 2            | 1.62 seconds        |
| **Numerics**       | 1,000,000  | Level 2            | 1.05 seconds        |
| **Dates**          | 1,000,000  | Level 2            | 2.99 seconds        |
| **License Plates** | 1,000,000  | Level 2            | 2.32 seconds        |
| **Phone Numbers**  | 1,000,000  | Level 2            | 3.42 seconds        |

## Running Unit Tests

Unit tests are located in the `test/` directory and use the `unittest` framework. To run the unit tests, navigate to the root directory of your project and use:

```bash
python3 -m unittest test/test_file.py
```

To run all tests in the `test/` directory, use:

```bash
python3 -m unittest discover -s test
```

### Test Output

After running the tests, you will see output indicating which tests passed and which failed. A successful test run will show:

```
...
----------------------------------------------------------------------
Ran X tests in Y.YYYs

OK
```
